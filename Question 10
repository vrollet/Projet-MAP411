# -*- coding: utf-8 -*-
"""
Created on Mon Dec 11 14:31:09 2017

@author: jerem
"""

import matplotlib.pyplot as plt
import numpy as np
import math
import scipy
from scipy import integrate as integr
from scipy import optimize as opti
  
#Paramètres du modèle
  
a_max = 2
T_max = 2*a_max
N_a = 120
N_t = 50
Dt = T_max/N_t
Da = a_max/N_a
CFL = Dt*N_a/a_max
  
def beta(a):
    return 10*a*(a_max - a)*math.exp(-20*(a-(a_max/3))**2)

def mu(a):
    return 1/(a_max-a)
     
def zeta(a):
    return math.exp(-30*(a-(a_max/4))**2)
 
def draw_beta_mu():
     
    resolution = 0.005
    
    x = [i*resolution for i in range(int(a_max/resolution))]
    y = [beta(a) for a in x]   
    y2 = [mu(a) for a in x]
    plt.axis([0, a_max, 0, 10])
    plt.plot(x,y, label='beta')
    plt.plot(x,y2, label = 'mu')
    plt.legend()
    plt.show()
     
    return
 
 
def question2():
     #On implémente le schéma implicite décentré amont proposé
     #On commence par définir la matrice B telle que B P_(n+1) = P_n
     B = scipy.sparse.diags([-CFL, 1+CFL+Dt*mu(Da)], [-1, 0], shape=(N_a, N_a), format = 'csc')
     #On trouve l'inverse de B
     B_I = scipy.sparse.linalg.inv(B)
     #On implémente le schéma
     return B_I
     
def pi(x):
    (C,err)=integr.quad(mu,0,x)
    return np.exp(-C) 

def F(x):
    F = -1 + 0.5*beta(0)*pi(0) + 0.5*beta(a_max)*pi(a_max*0.999999999999)*np.exp(-x*a_max)
    for i in range(1,N_a):
        F += beta(i*Da)*np.exp(-x*i*Da)*pi(i*Da)
    return F
     
def question10():
    #On implémente la résolution par un algorithme de Newton et on la compare
    #avec la solution proposée par Python
    
    #Paramètres de la méthode de Newton
    x0=1 
    epsilon=1e-6
    h=1e-4

    #Algorithme 
    x = x0 # Initialisation
   # while abs(F(x)) > epsilon:
    for i in range (1,11):
        derivee = (F(x+h) - F(x)) / h # dérivée en x_k par taux d’accroissement
        x = x - F(x)/derivee # nouvelle valeur x_{k+1} de x
        print x
    #Comparaison des résultats
    verif = opti.fsolve(F,1)
    return (x,verif) 
